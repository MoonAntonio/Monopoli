#ifndef __L_UIMSG_H__
#define __L_UIMSG_H__

/*****************************************************************************
 *   FILE:    L_UIMsg.h
 *   AUTHOR:  DCF, January 1998
 *
 *   (C) Copyright 1998 Artech Digital Entertainments.
 *                      All rights reserved.
 *
 * $Header: /Artlib_99/ArtLib/L_UIMsg.h 7     26/09/99 3:18p Agmsmith $
 *
 * This module defines a mechanism for maintaining an event
 * queue for interaction between the user and the system code.
 * Events are defined for various interactions ( buttons etc. )
 * and are stored in a Queue. The user can receive events
 * and process them as required.
 *****************************************************************************
 * $Log: /Artlib_99/ArtLib/L_UIMsg.h $
 * 
 * 7     26/09/99 3:18p Agmsmith
 * Added queue size reporting function.
 *
 * 6     7/12/99 11:32a Agmsmith
 * Documentation correction.
 ****************************************************************************/

/************************************************************/
/* EXPORTED DATA STRUCTURES AND TYPES                       */
/************************************************************/

typedef enum LE_UIMSG_MessageEnum
{
  UIMSG_NONE = 0,
      /* Nothing has happened.  This is a NULL message.  Normally you won't
      receive this message, so it is only useful for internal message
      processing where you don't want to do anything. */

  /* The following messages prefixed with UIMSG_BUTTON are generated by the
  button code. The user just receives them from the event queue and processes
  them as necessary. In all button messages, the value of numberA contains the
  list number and numberB contains the button number in the list. The X and
  Y coordinates relative to the screen where the event occured will be
  placed in numberD and numberE respectively. */

  UIMSG_BUTTON_PRESSED,
  UIMSG_BUTTON_RELEASED,
    /* Messages are sent when a button is pressed and released respectively.
    The value of numberC will contain the activation method ( see BUTTON.H
    for a description of BUTTON_ActivationType ). */
  UIMSG_BUTTON_ROLL_ENTER,
  UIMSG_BUTTON_ROLL_EXIT,
    /* Messages sent when the mouse first enters and leaves the buttons
    active area respectively. The button must be sensitive to rollover
    ( activateRollOver = TRUE ). */
  UIMSG_BUTTON_TRACK,
    /* Messages sent when the mouse moves over the active region of a
    button. The mouse X screen coordinate is in numberC and the Y
    screen coordinate is in number D. The button must be sensitve to
    mouse tracking ( activateTrack = TRUE ). */
  UIMSG_BUTTON_ON_OFF,
    /* Message is sent when a button has been switched between on and off.
    This happens when you release the mouse button while the mouse is over
    the button. NumberD is TRUE for ON, FALSE for OFF. */


  /* The keyboard module generates these messages. */

  UIMSG_KEYBOARD_PRESSED,
    /* A key has been pressed down.  NumberA is the key code of type
    LE_KEYBRD_ScanCodes.  NumberB is the Windows key code.  This doesn't
    include autorepeat key presses, which will be ignored. */
  UIMSG_KEYBOARD_RELEASED,
    /* A key has been let go.  NumberA is the LE_KEYBRD_ScanCodes code
    and NumberB is the Windows key code. */
  UIMSG_KEYBOARD_ACHAR,
    /* An ASCII or Unicode key combination has been pressed (includes lower
    case and upper case and but probably not Japanese (you need to create a
    text entry window which can pop up sub-windows showing alternatives
    to the initial phonetic symbols typed in).  The ACHAR is in NumberA.
    This one can auto-repeat. */


  /* Mouse activity gets reflected in these messages. */

  UIMSG_MOUSE_LEFT_DOWN,
  UIMSG_MOUSE_LEFT_UP,
  UIMSG_MOUSE_MIDDLE_DOWN,
  UIMSG_MOUSE_MIDDLE_UP,
  UIMSG_MOUSE_RIGHT_DOWN,
  UIMSG_MOUSE_RIGHT_UP,
    /* The mouse button has been pressed or released.  NumberA is the X
    coordinate and NumberB the Y of the mouse where the click happened,
    NumberC and NumberD contain deltas since the last mouse operation,
    possibly duplicating ones in UIMSG_MOUSE_MOVED (the same mouse action
    may generate UP messages and MOVED messages). */
  UIMSG_MOUSE_MOVED,
    /* The mouse has moved, new position X and Y are in NumberA and NumberB,
    DeltaX and DeltaY (change in X and Y) are in NumberC and NumberD.
    Only sends this message when there is a non-zero delta.  Also, this
    message gets dropped from the queue if the queue is half full, since
    you don't miss much if a few of these messages get tossed (so the
    deltas may not add up, use LE_MOUSE_MouseDeltaX if you really want
    the cumulative delta).  The C_Artlib.h CE_ARTLIB_MousePositionMessages
    define controls the generation of these messages. */


  /* Messages from the timer module. */

  UIMSG_TIMER_REACHED_ZERO,
    /* A timer has counted down to zero.  NumberA identifies the timer
    (the index into the LE_Timers array).  NumberB is the global tick
    count (LE_TIME_TickCount) when the timeout happened.  Some timers
    stop when they reach zero, so you only get one of these for them.
    Other timers restart when they reach zero, so you can get several
    of these messages from them. */


  /* Messages from the animation sequencer. */

  UIMSG_SEQUENCE_STARTED,
    /* A sequence with a non-zero label has been started.  NumberA is
    the DataID of the sequence, NumberB is the priority, NumberC is
    the label, NumberD is the sequence type, NumberE is the update
    count.  All activity in the same update will have the same count
    (taken from TopLevelClock in L_SEQNCR.C). */
  UIMSG_SEQUENCE_REACHED_END,
    /* A sequence with a non-zero label has reached its end time and
    will be looping, pausing or stopping.  NumberA is the DataID of
    the sequence, NumberB is the priority, NumberC is the label,
    NumberD is the ending action type, NumberE is the update count. */
  UIMSG_SEQUENCE_DELETED,
    /* A sequence with a non-zero label is being deleted (includes
    all sequence ending activity, not just reaching the end of time).
    NumberA is the DataID of the sequence, NumberB is the priority,
    NumberC is the label, NumberD is the sequence type, NumberE is
    the update count. */


  /* Messages from the video player. */

  UIMSG_VIDEO_JUMP,
    /* The video player has hit a jump point (alternative path).  The
    decision frame number (last common frame between two alternative
    paths) is in NumberA.  The alternative path frame number is in
    NumberB (even if it isn't taken).  The path taken flag (TRUE if
    alternative taken, FALSE if playing straight through) is in
    NumberC.  The DataID and Priority of the related sequence isn't
    currently available, presumably you are only running one video
    with jump points at a time. */


  /* Miscellaneous messages. */

  UIMSG_SYSTEM_EXIT_PROGRAM,
    /* The program is shutting down.  Stop waiting for messages after you
    get this one!  The message queue is about to be deleted too. */

  UIMSG_NUMBER_OF_MESSAGES
    /* Valid message codes are >= 0 and less than this.  Leave this
    symbol at the end of the enum.  You can add your own custom message
    numbers after this (use UIMSG_NUMBER_OF_MESSAGES + 1 and so on). */

} LE_UIMSG_MessageType;



/************************************************************/
/* EXPORTED FUNCTIONS                                       */
/************************************************************/

extern int LE_UIMSG_InitializeSystem( void );
  /* Initialize the event queue system. This routine must be called
  once before either sending or receiving events. */

extern void LE_UIMSG_RemoveSystem( void );
  /* Cleanup and remove the queue system. All unused events still
  on the queue are removed and their associated memory freed. */

extern int LE_UIMSG_SendEvent (LE_UIMSG_MessageType event,
  long            numberA,
  long            numberB,
  long            numberC,
  long            numberD,
  long            numberE,
  ACHAR          *stringA,
  unsigned short  binarySize
);
  /* Generate an event and place it on the event queue.  The parameters numberA
  through numberE as well as stringA and binarySize correspond to the queue
  parameters.  Most events are generated internally by the system software so
  the user need no worry about calling this routine.  However, it is available
  if the need arises.  Returns non zero if the operation was successful. */

extern int LE_UIMSG_ReceiveEvent( LE_QUEUE_MessagePointer message );
extern void LE_UIMSG_WaitEvent( LE_QUEUE_MessagePointer message );
  /* Remove the next event from the event queue.  WaitEvent will wait until
  one is available while ReceiveEvent will return right away.  The event is
  in the form of a queue message record.  The 'message' field from the record
  corresponds to the event type (LE_UIMSG_MessageType type).  If no events
  are available on the queue, zero is returned and the value of message is
  undefined.  Remember to call LE_QUEUE_FreeStorageAssociatedWithMessage
  once you have finished processing the message (it frees the string field). */

extern void LE_UIMSG_FlushEvents (void);
  /* Remove all messages from the queue.  Useful if something happened in
  the game and you don't want to see events that happened recently after
  it (like timeouts that got queued after the button press). */

extern int LE_UIMSG_PercentageFull (void);
  /* Returns the current queue size, 0 means empty, 100 means full and values
  inbetween mean a partially full queue. */

#endif /* __L_UIMSG_H__ */
