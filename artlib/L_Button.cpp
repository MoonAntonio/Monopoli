/*****************************************************************************
 *
 *  FILE:        L_BUTTON.C
 *
 *  DESCRIPTION: This file contains an implementation of buttons. For a
 *               complete description of buttons and how they are used,
 *               see the file L_BUTTON.H.
 *
 * © Copyright 1998 Artech Digital Entertainments.  All rights reserved.
 *
 * $Header: /Artlib_99/ArtLib/L_Button.cpp 15    23/04/99 16:40 Timp $
 *****************************************************************************
 * $Log: /Artlib_99/ArtLib/L_Button.cpp $
 * 
 * 15    23/04/99 16:40 Timp
 * Minor changes
 * 
 * 14    4/12/99 3:40p Agmsmith
 * Use GetLoadedDataType instead of current, unless you know what you are
 * doing.
 *
 * 13    3/31/99 4:28p Timp
 * Added (ACHAR *) casts to LE_FONTS calls needed for Unicode.
 *
 * 12    3/24/99 7:52p Timp
 * Removed alpha parameter from LE_FONTS_Print() call.
 *
 * 11    3/24/99 12:46p Timp
 * Added alpha parameter to LE_FONTS_Print() call.
 *
 * 10    3/17/99 10:30a Agmsmith
 * Don't try to deallocate invalid DataIDs.
 *
 * 9     12/09/98 5:10p Agmsmith
 * DataImaginary changed to more meaningful DataNative (for native screen
 * depth image).
 *
 * 8     11/02/98 5:24p Agmsmith
 * Function name changes.
 *
 * 7     10/29/98 6:36p Agmsmith
 * New improved memory and data system added.  Memory and data systems
 * have been separated.  Now have memory pools, and optional corruption
 * check.  The data system has data groups rather than files and
 * individual items can come from any data source. Also has a least
 * recently used data unloading system (rather than programmer set
 * priorities).  And it can all be turned off for AndrewX!
 *
 * 6     10/16/98 2:20p Tomasz
 *
 * 5     10/07/98 3:08p Tomasz
 *
 * 4     10/06/98 2:05p Agmsmith
 * Updated define names to work with CE_ARTLIB_
 *
 * 3     9/15/98 12:03p Agmsmith
 * Added a #if around the whole thing to turn it off if the button system
 * isn't being used.
 *
 * 2     9/14/98 12:38p Agmsmith
 * Does keyword expansion work now for .CPP files?
 ****************************************************************************/

#include "l_inc.h"

#if CE_ARTLIB_EnableSystemButton

#define BUTTON_FLAG_LMB                 ( 1<<0 )
#define BUTTON_FLAG_RMB                 ( 1<<1 )
#define BUTTON_FLAG_MMOVE               ( 1<<2 )
#define BUTTON_FLAG_FIRSTINSET          ( 1<<3 )
#define BUTTON_FLAG_LASTINSET           ( 1<<4 )
#define BUTTON_FLAG_BUTTONDOWN          ( 1<<5 )
#define BUTTON_FLAG_ROLLOVERSENT        ( 1<<6 )
#define BUTTON_FLAG_TRANSITION_STARTED  ( 1<<10 )
#define BUTTON_FLAG_REDRAW_BUTTON       ( 1<<11 )
#define BUTTON_FLAG_ACTIVATIONSTATES    0x001f
#define BUTTON_FLAG_CONTROLSTATES       0xffe0
  /* Flags determining status of an internal button. These flags are
  part of the activationFlags from the internal structure. */


typedef enum BUTTON_TransitionEnum
{
  BUTTON_TRANS_NONE,      // No transition.
  BUTTON_TRANS_PRESS,     // Press down with button or key.
  BUTTON_TRANS_UNPRESS,   // Forced release, mouse not over button.
  BUTTON_TRANS_RELEASE,   // Normal release, mouse was over button,

} LI_BUTTON_TransitionType;


typedef BOOL FUNC_BUTTONSETSTATE( int                         buttonList,
                                  int                         button,
                                  LI_BUTTON_TransitionType    ttype,
                                  LE_UIMSG_MessageType        event,
                                  LE_BUTTON_ActivationType    active,
                                  POINT                       p );
typedef FUNC_BUTTONSETSTATE *PFUNC_BUTTONSETSTATE;
  /* Prototype for a state transition function for each type of button. When
  a button is created, it is assigned a state transition function which, given
  a particular transition will set the next state for the button, display the
  correct graphic for the new state and place an event on the event queue if
  required. The function will return TRUE if the button was placed in a new
  state, and FALSE if the transition was illegal.
    The values of buttonList and button identify the particular button that
  is changing state. The 'event' is the event type generated by the transition. */


typedef struct BUTTON_InternalButtonStruct
{
  LE_BUTTON_DefinitionRecord record;
    /* Copy of the button definition record used to create this button. During
    a call to the routine LE_BUTTON_UpdateButtonList() This is compared with the
    users local array and any differences are applied to the internal button. */

  short activationFlags;
    /* Status flags for button. This variable contains any combination of
    the button flags defined above with the prefix BUTTON_FLAG_. */

  PFUNC_BUTTONSETSTATE setState;
    /* Function for handling state transitions for this button. This function
    is called when the user interacts with the button with either the
    mouse or the keyboard.*/

} LI_BUTTON_InternalButtonRecord, *LI_BUTTON_InternalButtonPointer;
  /* Structure definition for the internal representation of a button. */


typedef struct BUTTON_ButtonListStruct
{
  BOOL active;
    /* If this value is TRUE all buttons in the list are potentially
    active, if FALSE, no buttons are active regardless of their state. */

  int numberOfButtons;
    /* The number of buttons stored in this list. */

  LE_BUTTON_DefinitionPointer userRecords;
    /* Pointer to the users local array used to create this button list. This
    value is used during the processing of transitions. */

  LE_BUTTON_TextInfoRecord textInfo;
    /* Information on how to draw all text buttons created for this list.
    This value is set by the user. When the button system gets initialized,
    this is given default values. */

  LE_DATA_DataId pressedSfx, releasedSfx;
    /* Sound effects to be played for all buttons that make are noisy. Buttons
    make a sound when they are pressed, released or both. If you do not want
    a button to make a sound for a particular state, set it it LED_EI. */

  HANDLE accessMutex;
    /* Mutex for maintaining mutually exclusive access to this list. All read
    and write operations on this list must first obtain access by waiting for
    this mutex to become signalled. The user does not need to be concerned
    with this as it is used internally. */

#if CE_ARTLIB_EnableSystemSequencer
  LE_REND_RenderSlot renderSlot;
    /* The render slot where this list of buttons are being displayed. This
    is needed to translate between screen and world coordinates. */
#endif

  LI_BUTTON_InternalButtonPointer buttons;
    /* Array of internal button records for this list. */

  LE_SPRITE_Pointer sprites;
    /* Pointer to the start of an array of sprites. There is one sprite
    for every button in this button list. The sprites are used to display
    the buttons. */

} LI_BUTTON_ButtonListRecord, *LI_BUTTON_ButtonListPointer;
  /* Structure definition for a button list. The button list maintains an internal
  button record for every button in the list. It also maintains an array of hotspot
  pointers which correspond directly with the hotspots maintained for every button
  in the internal button record. This is used for the calls to the hotspot
  processing routines. */


static LI_BUTTON_ButtonListRecord Buttons[ CE_ARTLIB_NumberOfButtonLists ];
  /* Array of button lists. Each entry is a button list that was defined by
  the user during a call to LE_BUTTON_UpdateButtonList(). */


#define BUTTON_INTPTR(l,b)  ( &( Buttons[ l ].buttons[ b ] ) )
#define BUTTON_SPRPTR(l,b)  ( &( Buttons[ l ].sprites[ b ] ) )
#define BUTTON_USRPTR(l,b)  ( &( Buttons[ l ].userRecords[ b ] ) )
  /* Macros for obtaining pointers to indexed items contained in any
  button list. */



/*****************************************************************************
 *
 * LE_DATA_DataId LI_BUTTON_MakeTextButton( LE_BUTTON_TextInfoPointer textInfo,
 *                                       LE_DATA_DataId textID, DWORD colNum )
 *
 *
 *  Description:
 *    Creates a new object for a text button given a text info structure
 *    a string and a text color.
 *
 *  Parameters:
 *    textInfo    - Pointer to structure containing info for button.
 *    text        - Text placed inside the button.
 *    color       - Color of text. 0 means use offColor, 1 means use
 *                  on color, 2 means use disabled color.
 *
 *  Returns:
 *    Id of new object for button, LED_EI if an error occured.
 *
 *  Note the use of ACHAR.  Depending on CE_ARTLIB_UnicodeAlphabet,
 *  the text must be either ASCII or Unicode.  (See L_Type.h)
 *
 *****************************************************************************/

LE_DATA_DataId LI_BUTTON_MakeTextButton( LE_BUTTON_TextInfoPointer textInfo,
                                         LE_DATA_DataId textID, DWORD colNum )
{
  LE_DATA_DataId  object = LED_EI;
  LE_DATA_DataId  base_tag_a;
  LE_DATA_DataId  base_tag_b;
  LE_DATA_DataId  base_tag_c;
  short           w_elements;
  short           h_elements;
  short           frameLine, i;
  short           frameWidth, frameHeight, textWidth, textHeight, Y;
  ACHAR *         text;
  DWORD           color;

  // Load the text from the data file.
  text = (ACHAR *) LE_DATA_Use (textID);

  // Get the color.
  if ( colNum == 0 )
    color = textInfo->offColor;
  else if ( colNum == 1 )
    color = textInfo->onColor;
  else
    color = textInfo->disabledColor;

  // Find the dimensions of the string in terms of pixels.
  textWidth  = LE_FONTS_GetStringWidth ( text );
  textHeight = LE_FONTS_GetStringHeight( text );

  // Extra check. If the user doesn't want to provide graphics for the
  // button frame, the dimension value will be 0. To make our
  // calculations work, set it to 1.
  if ( textInfo->dimension <= 0 )
    textInfo->dimension = 1;

  // Find the dimensions of the frame. This will be a combination of
  // the width of the text and the dimension of the frame graphics.
  // We will leave an extra space of 1 graphic dimension on all 4
  // sides of the text.
  frameWidth  = textWidth  + ( 2 * textInfo->dimension );
  frameHeight = textHeight + ( 2 * textInfo->dimension );

  // Round down the dimensions of the frame to an even number of graphic
  // dimensions so everything will be square.
  frameWidth  += textInfo->dimension + frameWidth  % textInfo->dimension;
  frameHeight += textInfo->dimension + frameHeight % textInfo->dimension;

  // Create the object to hold the frame image.
  object = LE_GRAFIX_ObjectCreateAlpha( frameWidth, frameHeight, FALSE, ALPHA_OPAQUE81_25);

  if ( object != LED_EI )
  {
    w_elements = frameWidth  / textInfo->dimension;
    h_elements = frameHeight / textInfo->dimension;

    // Loop for each horizontal line. This will build the graphic frame.
    for( frameLine=0; frameLine < h_elements; frameLine++ )
    {
      // Get the Y coordinate value. Its used alot.
      Y = frameLine * textInfo->dimension;

      // Top line of frame.
      if ( frameLine == 0 )
      {
        base_tag_a = textInfo->topLeftCorner;
        base_tag_b = textInfo->topEdge;
        base_tag_c = textInfo->topRightCorner;
      }
      // Bottom line of frame.
      else if  (frameLine == h_elements-1 )
      {
        base_tag_a = textInfo->bottomLeftCorner;
        base_tag_b = textInfo->bottomEdge;
        base_tag_c = textInfo->bottomRightCorner;
      }
      // Middle lines of frame.
      else
      {
        base_tag_a = textInfo->leftEdge;
        base_tag_b = textInfo->center;
        base_tag_c = textInfo->rightEdge;
      }

      // Show the far left image.
      if ( base_tag_a != LED_EI )
        LE_GRAFIX_ShowTCB( object, 0, Y, base_tag_a );

      // Show the middle images.
      if ( base_tag_b != LED_EI )
      {
        for ( i=1; i<w_elements-1; i++ )
          LE_GRAFIX_ShowTCB( object, (short)(i * textInfo->dimension), Y, base_tag_b );
      }

      // Show the far right image.
      if ( base_tag_c != LED_EI )
        LE_GRAFIX_ShowTCB( object, (short)(( w_elements-1 ) * textInfo->dimension), Y, base_tag_c );
    }

    // All that is left is to display the text in the middle of the frame.
    // Find the middle of the frame, then offset for upper left corner
    // of frame around text, as this is needed for printing on object.
    w_elements = ( frameWidth  / 2 ) - ( textWidth  / 2 );
    h_elements = ( frameHeight / 2 ) - ( textHeight / 2 );

    LE_FONTS_Print( object, w_elements, h_elements, color, text );
  }

  return( object );
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_IsLegalButton( int buttonList, int button )
 *
 *  Description:
 *    Internal routine that will determine if a given button from a button
 *    list is valid. Used in routines that require the user to supply this
 *    information.
 *
 *  Parameters:
 *    buttonList - Button list identifier.
 *    button     - Button identifier from specified list.
 *
 *  Returns:
 *    TRUE if it is a valid button, FALSE otherwise.
 *
 *****************************************************************************/

static BOOL LI_BUTTON_IsLegalButton( int buttonList, int button )
{
  // Invalid button list specified.
  if ( buttonList < 0 || buttonList >= CE_ARTLIB_NumberOfButtonLists )
    return( FALSE );
  // Invalid button.
  if ( button < 0 || button >= Buttons[ buttonList ].numberOfButtons )
    return( FALSE );
  // OK
  return( TRUE );
}


/*****************************************************************************
 *
 * static LE_DATA_DataId LI_BUTTON_GetOrSetStateImage( int, int, LE_DATA_DataId, BOOL )
 *
 *  Description:
 *    This routine will set and/or return the ID value of the next stable
 *    state image of the specified button. If the value of isImage is TRUE,
 *    the the next current stable state image will be replaced with the image
 *    given by the parameter 'image'.
 *
 *  Parameters:
 *    bList, button   - Identifies the button.
 *    image           - New image for button stable state.
 *    isImage         - If TRUE, 'image' contains new image for button.
 *
 *  Returns:
 *    ID value of next stable state image. Could be the image that was just
 *    modified.
 *
 *****************************************************************************/

static LE_DATA_DataId LI_BUTTON_GetOrSetStateImage( int bList, int button,
LE_DATA_DataId image, BOOL isImage )
{
  LI_BUTTON_InternalButtonPointer intBut = BUTTON_INTPTR( bList, button );

  // BUTTON is PRESSED
  if ( intBut->record.isPressed )
  {
    if ( isImage )
      intBut->record.pressedImage = image;
    else
      image = intBut->record.pressedImage;
  }
  // BUTTON is UNPRESSED
  else
  { // If a new image is defined, set the internal records.
    if ( isImage )
    {
      if ( intBut->record.isOn )
        intBut->record.onImage = image;
      else
        intBut->record.offImage = image;
    }
    // Otherwise, figure out what the next image is.
    else
      image = ( intBut->record.isOn ) ? intBut->record.onImage : intBut->record.offImage;
  }
  // BUTTON is DISABLED.
  if ( intBut->record.isDisabled && isImage )
    intBut->record.disabledImage = image;
  if ( intBut->record.isDisabled && intBut->record.disabledImage != LED_EI )
    image = intBut->record.disabledImage;

  // Return the new image.
  return( image );
}


/*****************************************************************************
 *
 * static void LI_BUTTON_DoTransitions( int bList )
 *
 *  Description:
 *    Go through all buttons contained in the specified button list and
 *    start any transition sequences requested to play. This will not handle
 *    any redrawing of button stable states but will set flags to indicate
 *    how to redraw them.
 *
 *  Parameters:
 *     bList    - Button list number.
 *
 *  Returns:
 *     None.
 *
 *****************************************************************************/

static void LI_BUTTON_DoTransitions( int bList )
{
  LI_BUTTON_InternalButtonPointer but;
  LE_BUTTON_DefinitionPointer user;
  LE_SPRITE_Pointer sprPtr;
  BOOL transitionsWereStarted = FALSE;
  int numButtons = Buttons[ bList ].numberOfButtons;
  int i;

  // Go through each button in the button list.
  for( i=0; i<numButtons; i++ )
  {
    // Get a pointer to the users defintion record.
    user = BUTTON_USRPTR( bList, i);
    // If a transition is not defined for this button, skip it.
    if ( user->transitionDefined == FALSE ) continue;
    // Get information about the button.
    but    = BUTTON_INTPTR( bList, i );
    sprPtr = BUTTON_SPRPTR( bList, i );
    // If the disabledButton flag is set. Disable immediately.
    if(  user->transition.disableButton )
    {
      but->record.isDisabled = TRUE;
      user->transition.disableButton = FALSE;
    }
    // If a new active area is defined. Set immediately.
    if ( user->transition.nextActiveAreaDefined )
    {
      but->record.rectangle = user->transition.nextActiveArea;
      user->transition.nextActiveAreaDefined = FALSE;
    }
    // If a valid transition is defined, begin playing it.
    if ( user->transition.transitionSequenceDefined )
    { // Play the transition sequence at the defined starting location.
      LE_SPRITE_SetPosition( sprPtr, user->transition.transitionX, user->transition.transitionY, FALSE );
      LE_SPRITE_SetImage( sprPtr, user->transition.transitionSequence, FALSE, TRUE );
      // Set the flag in the internal structure to signify that a transition is playing.
      but->activationFlags |= BUTTON_FLAG_TRANSITION_STARTED;
      user->transition.transitionSequenceDefined = FALSE;
      transitionsWereStarted = TRUE;
    }
    // Set the new image if one is defined.
    if ( user->transition.nextImageDefined )
    {
      LI_BUTTON_GetOrSetStateImage( bList, i, user->transition.nextImage, TRUE );
      user->transition.nextImageDefined = FALSE;
    }
    // If the button is requested to be hidden,
    if ( user->transition.hideButton )
    {
      but->record.isVisible = FALSE;
      user->transition.hideButton = FALSE;
    }
    // If asked to redraw the buttons, set the redraw flag.
    if ( user->transition.redrawButton )
    {
      but->activationFlags |= BUTTON_FLAG_REDRAW_BUTTON;
      user->transition.redrawButton = FALSE;
    }
    user->transitionDefined = FALSE;
  } // End of FOR loop.

  // Update the sprites if any transitions were started.
  if ( transitionsWereStarted )
    LE_SPRITE_UpdateSprites( BUTTON_SPRPTR( bList, 0 ), numButtons );
}


/*****************************************************************************
 *
 * void LI_BUTTON_RedrawButtons( int bList )
 *
 *  Description:
 *    Displays all buttons in a list to their next stable state that have
 *    the BUTTON_FLAG_REDRAW_BUTTON set. Will chain to the end a transition
 *    sequence if one was started. This routine will clear all
 *    BUTTON_FLAG_TRANSITION_STARTED and BUTTON_FLAG_REDRAW_BUTTON flags.
 *    for every button whether they were redrawn or not.
 *
 *  Parameters:
 *    bList   - Button list number.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

void LI_BUTTON_RedrawButtons( int bList )
{
  LI_BUTTON_InternalButtonPointer intBut;
  LE_SPRITE_Pointer sprPtr;
  LE_DATA_DataId image;
  int numButtons = Buttons[ bList ].numberOfButtons;
  int i;

  // Go through all buttons again and any that have the redrawButton
  // flag set, display the next state for the button.
  for( i=0; i<numButtons; i++ )
  {
    // Get some button specifics.
    intBut = BUTTON_INTPTR( bList, i );
    sprPtr = BUTTON_SPRPTR( bList, i );
    // If not redrawing, skip button and clear chain flag.
    if ( !( intBut->activationFlags & BUTTON_FLAG_REDRAW_BUTTON ) )
    { // Don't need this flag anymore.
      intBut->activationFlags &= ~BUTTON_FLAG_TRANSITION_STARTED;
      continue;
    }
    // Get the next image to display for the sprite. If a new image is defined, use it.
    image = LI_BUTTON_GetOrSetStateImage( bList, i, LED_EI, FALSE );
    // Update the current position of the sprite using the active area.
    LE_SPRITE_SetPosition( sprPtr, (short)intBut->record.rectangle.left,
                                   (short)intBut->record.rectangle.top, FALSE );
    // If the button is pressed and the simulatePress flag is set, add a bit of an offset.
    if ( intBut->record.isPressed && intBut->record.simulatePress )
      LE_SPRITE_SetPosition( sprPtr, 3, 3, TRUE );
    // Set up the sprite.
    if ( intBut->record.isVisible == FALSE )
    { // If the button is not visible, but a transition sequence is playing, chain LED_EI
      // to the end of the sequence, otherwise just hide the sprite.
      if ( intBut->activationFlags & BUTTON_FLAG_TRANSITION_STARTED )
        LE_SPRITE_SetImage( sprPtr, LED_EI, TRUE, FALSE );
      else
        LE_SPRITE_SetVisible( sprPtr, FALSE );
    }
    else
    { // Sprite is visible. Set status and next image. Chain the image to the end of
      // the transition sequence if one was started.
      LE_SPRITE_SetVisible( sprPtr, TRUE );
      if ( image != LED_EI )
        LE_SPRITE_SetImage( sprPtr, image, TRUE, !( intBut->activationFlags & BUTTON_FLAG_TRANSITION_STARTED ) );
    }
    // Clear all drawing flags.
    intBut->activationFlags &= ~(BUTTON_FLAG_REDRAW_BUTTON|BUTTON_FLAG_TRANSITION_STARTED);
  }
  // Last step. Update all button sprites.
  LE_SPRITE_UpdateSprites( BUTTON_SPRPTR( bList, 0 ), numButtons );
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_PressButton( int bList, int but )
 *
 *  Description:
 *    Sets a button to the pressed state. Sets the BUTTON_FLAG_REDRAW_BUTTON
 *    so it will be updated during the next call to redraw buttons.
 *
 *  Parameters:
 *    bList, but  - Identifies the button.
 *
 *  Returns:
 *    TRUE if the button was pressed, FALSE if it already is pressed.
 *
 *****************************************************************************/

static BOOL LI_BUTTON_PressButton( int bList, int button )
{
  LI_BUTTON_InternalButtonPointer but = BUTTON_INTPTR( bList, button );

  if ( but->record.isPressed == FALSE )
  { // Set the pressed state and redraw flag only.
    but->record.isPressed = TRUE;
    but->activationFlags |= BUTTON_FLAG_REDRAW_BUTTON;
    return( TRUE );
  }
  return( FALSE );
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_ReleaseButton( int bList, int but )
 *
 *  Description:
 *    Releases a button from a pressed state. Sets the flag so the button
 *    will redraw.
 *
 *  Parameters:
 *    bList, but  - Identifies the button.
 *
 *  Returns:
 *    TRUE if button was released, FALSE if the button was not pressed.
 *
 *****************************************************************************/

static BOOL LI_BUTTON_ReleaseButton( int bList, int button )
{
  LI_BUTTON_InternalButtonPointer but = BUTTON_INTPTR( bList, button );

  if ( but->record.isPressed )
  { // Set the state and set the redraw flag.
    but->record.isPressed = FALSE ;
    but->activationFlags |= BUTTON_FLAG_REDRAW_BUTTON;
    return( TRUE );
  }
  return( FALSE );
}


/*****************************************************************************
 *
 * static void LI_BUTTON_TurnOffButtons( int buttonList, int button )
 *
 *  Description:
 *    Internal routine that will set all buttons in a set to the
 *    BUTTON_STATE_OFF state given a button in that set. The button that is
 *    specified is not affected. This is used to preserve the mutual
 *    exclusivity required for radio and cycle buttons.
 *
 *  Parameters:
 *    buttonList, button - Identifies the button on which to force exclusivity.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

static void LI_BUTTON_TurnOffButtons( int buttonList, int button )
{
  LI_BUTTON_InternalButtonPointer but = BUTTON_INTPTR( buttonList, button );
  int workingButton;

  // Work forwards from the active button if it is not the last button.
  if ( !( but->activationFlags & BUTTON_FLAG_LASTINSET ) )
  {
    workingButton = button + 1;
    while( workingButton < Buttons[ buttonList ].numberOfButtons )
    {
      but = BUTTON_INTPTR( buttonList, workingButton );
      LI_BUTTON_ReleaseButton( buttonList, workingButton );
      if ( but->record.offImage == LED_EI ) but->record.isVisible = FALSE;
      but->record.isOn = FALSE;
      but->activationFlags |= BUTTON_FLAG_REDRAW_BUTTON;
      if ( but->activationFlags & BUTTON_FLAG_LASTINSET ) break;
      workingButton++;
    }
  }
  // Working backwards from the active button if it is not the first button.
  if ( !( but->activationFlags & BUTTON_FLAG_FIRSTINSET ) )
  {
    workingButton = button - 1;
    while( workingButton >= 0 )
    {
      but = BUTTON_INTPTR( buttonList, workingButton );
      LI_BUTTON_ReleaseButton( buttonList, workingButton );
      if ( but->record.offImage == LED_EI ) but->record.isVisible = FALSE;
      but->record.isOn = FALSE;
      but->activationFlags |= BUTTON_FLAG_REDRAW_BUTTON;
      if ( but->activationFlags & BUTTON_FLAG_FIRSTINSET ) break;
      workingButton--;
    }
  }
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_InternalSetStateForHotspot( ... )
 *
 *  Description:
 *    Internal state transition function for a HOTSPOT button. This function
 *    gets assigned to the button when the button is created in the
 *    LE_BUTTON_UpdateButtonList() call. Each transition function works by
 *    examining the transition type and setting the button to the appropriate
 *    next state. If the button changes state, it is flagged to be redrawn
 *    and any events generated are placed on the event queue.
 *
 *  Parameters:
 *    buttonList, button  - Identifies the button to perform state transition.
 *    ttype               - State transition type.
 *    event               - Type of event to generate if button changes state.
 *    active              - How the button was activated.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

static void LI_BUTTON_InternalSetStateForHotspot( int buttonList, int button,
LI_BUTTON_TransitionType ttype, LE_UIMSG_MessageType event,
LE_BUTTON_ActivationType active, POINT p )
{
  switch( ttype )
  {
  case BUTTON_TRANS_PRESS:
    LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
    break;

  case BUTTON_TRANS_UNPRESS:
  case BUTTON_TRANS_RELEASE:
    if ( ttype == BUTTON_TRANS_RELEASE )
      LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
    break;
  }
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_InternalSetStateForMomentary( ... )
 *
 *  Description:
 *    Internal state transition function for a MOMENTARY button. This function
 *    gets assigned to the button when the button is created in the
 *    LE_BUTTON_UpdateButtonList() call. Each transition function works by
 *    examining the transition type and setting the button to the appropriate
 *    next state. If the button changes state, it is flagged to be redrawn
 *    and any events generated are placed on the event queue.
 *
 *  Parameters:
 *    buttonList, button  - Identifies the button to perform state transition.
 *    ttype               - State transition type.
 *    event               - Type of event to generate if button changes state.
 *    active              - How the button was activated.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

static void LI_BUTTON_InternalSetStateForMomentary( int buttonList, int button,
LI_BUTTON_TransitionType ttype, LE_UIMSG_MessageType event,
LE_BUTTON_ActivationType active, POINT p )
{
  LI_BUTTON_InternalButtonPointer but = BUTTON_INTPTR( buttonList, button );

  switch( ttype )
  {
  case BUTTON_TRANS_PRESS:
    // Only send the event if the button was pressed.
    if ( LI_BUTTON_PressButton( buttonList, button ) )
      LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
    break;

  case BUTTON_TRANS_UNPRESS:
  case BUTTON_TRANS_RELEASE:
    if ( LI_BUTTON_ReleaseButton( buttonList, button ) )
    { // Only send the event if the transition was a valid release.
      if ( ttype == BUTTON_TRANS_RELEASE )
        LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
    }
    break;
  }
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_InternalSetStateForToggle( ... )
 *
 *  Description:
 *    Internal state transition function for a TOGGLE button. This function
 *    gets assigned to the button when the button is created in the
 *    LE_BUTTON_UpdateButtonList() call. Each transition function works by
 *    examining the transition type and setting the button to the appropriate
 *    next state. If the button changes state, it is flagged to be redrawn
 *    and any events generated are placed on the event queue.
 *
 *  Parameters:
 *    buttonList, button  - Identifies the button to perform state transition.
 *    ttype               - State transition type.
 *    event               - Type of event to generate if button changes state.
 *    active              - How the button was activated.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

static void LI_BUTTON_InternalSetStateForToggle( int buttonList, int button,
LI_BUTTON_TransitionType ttype, LE_UIMSG_MessageType event,
LE_BUTTON_ActivationType active, POINT p )
{
  LI_BUTTON_InternalButtonPointer but = BUTTON_INTPTR( buttonList, button );

  switch( ttype )
  {
  case BUTTON_TRANS_PRESS:
    if ( LI_BUTTON_PressButton( buttonList, button ) )
      LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
    break;

  case BUTTON_TRANS_RELEASE:
  case BUTTON_TRANS_UNPRESS:
    if ( LI_BUTTON_ReleaseButton( buttonList, button ) )
    { // Only send the event if the transition was a valid release.
      if ( ttype == BUTTON_TRANS_RELEASE )
      { // Toggle the ON state.
        but->record.isOn = 1 - but->record.isOn;
        // Send a release event and a button toggle event.
        LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
        LE_UIMSG_SendEvent( UIMSG_BUTTON_ON_OFF, buttonList, button, active, TRUE, 0, NULL, 0 );
      }
    }
    break;
  }
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_InternalSetStateForRadio( ... )
 *
 *  Description:
 *    Internal state transition function for a RADIO button. This function
 *    gets assigned to the button when the button is created in the
 *    LE_BUTTON_UpdateButtonList() call. Each transition function works by
 *    examining the transition type and setting the button to the appropriate
 *    next state. If the button changes state, it is flagged to be redrawn
 *    and any events generated are placed on the event queue.
 *
 *  Parameters:
 *    buttonList, button  - Identifies the button to perform state transition.
 *    ttype               - State transition type.
 *    event               - Type of event to generate if button changes state.
 *    active              - How the button was activated.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

static void LI_BUTTON_InternalSetStateForRadio( int buttonList, int button,
LI_BUTTON_TransitionType ttype, LE_UIMSG_MessageType event,
LE_BUTTON_ActivationType active, POINT p )
{
  LI_BUTTON_InternalButtonPointer but = BUTTON_INTPTR( buttonList, button );

  switch( ttype )
  {
  case BUTTON_TRANS_PRESS:
    if ( LI_BUTTON_PressButton( buttonList, button ) )
      LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
    break;

  case BUTTON_TRANS_RELEASE:
  case BUTTON_TRANS_UNPRESS:
    if ( LI_BUTTON_ReleaseButton( buttonList, button ) )
    { // Only send the event if the transition was a valid release.
      if ( ttype == BUTTON_TRANS_RELEASE )
      { // Send release event.
        LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
        // Toggle the ON state if the button is not already ON.
        if ( but->record.isOn == FALSE )
        { // Turn off all other buttons.
          but->record.isOn = TRUE  ;
          LI_BUTTON_TurnOffButtons( buttonList, button );
          // Send a button toggle event.
          LE_UIMSG_SendEvent( UIMSG_BUTTON_ON_OFF, buttonList, button, active, TRUE, 0, NULL, 0 );
        }
      }
    }
    break;
  }
}


/*****************************************************************************
 *
 * static BOOL LI_BUTTON_InternalSetStateForCycle( ... )
 *
 *  Description:
 *    Internal state transition function for a CYCLE button. This function
 *    gets assigned to the button when the button is created in the
 *    LE_BUTTON_UpdateButtonList() call. Each transition function works by
 *    examining the transition type and setting the button to the appropriate
 *    next state. If the button changes state, it is flagged to be redrawn
 *    and any events generated are placed on the event queue.
 *
 *  Parameters:
 *    buttonList, button  - Identifies the button to perform state transition.
 *    ttype               - State transition type.
 *    event               - Type of event to generate if button changes state.
 *    active              - How the button was activated.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

static void LI_BUTTON_InternalSetStateForCycle( int buttonList, int button,
LI_BUTTON_TransitionType ttype, LE_UIMSG_MessageType event,
LE_BUTTON_ActivationType active, POINT p )
{
  LI_BUTTON_InternalButtonPointer but = BUTTON_INTPTR( buttonList, button );
  LI_BUTTON_InternalButtonPointer but2;
  int workingButton, nextButton;

  switch( ttype )
  {
  case BUTTON_TRANS_PRESS:
    if ( LI_BUTTON_PressButton( buttonList, button ) )
      LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
    break;

  case BUTTON_TRANS_RELEASE:
  case BUTTON_TRANS_UNPRESS:
    if ( LI_BUTTON_ReleaseButton( buttonList, button ) )
    { // Only send the event if the transition was a valid release.
      if ( ttype == BUTTON_TRANS_RELEASE )
      { // Find the next button to be turned on. If this button is the last in
        // the set, we need to find the first button.
        if ( but->record.buttonType == BUTTON_TYPE_LAST_CYCLE )
        { // Find the button that is currently ON.
          workingButton = button;
          nextButton    = -1;
          while( workingButton >= 0 && nextButton == -1 )
          {
            but2 = BUTTON_INTPTR( buttonList, workingButton );
            if ( but2->activationFlags & BUTTON_FLAG_FIRSTINSET )
              nextButton = workingButton;
            workingButton--;
          }
          if ( nextButton == -1 )
            nextButton = 0;
        }
        // Otherwise, its just the next button.
        else
          nextButton = button + 1;

        // We have the first button. Turn off all other buttons.
        LI_BUTTON_TurnOffButtons( buttonList, nextButton );
        // Send a release event and a button toggle event.
        LE_UIMSG_SendEvent( event, buttonList, button, active, p.x, p.y, NULL, 0 );
        LE_UIMSG_SendEvent( UIMSG_BUTTON_ON_OFF, buttonList, button, active, TRUE, 0, NULL, 0 );
      }
      // Show the new button in the ON state.
      but2 = BUTTON_INTPTR( buttonList, nextButton );
      but2->record.isOn = TRUE;
      but2->record.isVisible = TRUE;
    }
    break;
  }
}


/*****************************************************************************
 *
 * BOOL LI_BUTTON_InitializeSystem( void )
 *
 *  Description:
 *    Initializes the button system and assigns default values. Also creates
 *    the access mutex but does not initially request access.
 *
 *  Parameters:
 *    None.
 *
 *  Returns:
 *    TRUE if successful.
 *
 *****************************************************************************/

BOOL LI_BUTTON_InitializeSystem( void )
{
  int i;

  for( i=0; i< CE_ARTLIB_NumberOfButtonLists; i++ )
  {
    // Initialize default values.
    Buttons[ i ].numberOfButtons = 0;
    Buttons[ i ].active          = FALSE;
    Buttons[ i ].buttons         = NULL;
    Buttons[ i ].sprites         = NULL;
    Buttons[ i ].pressedSfx      = LED_EI;
    Buttons[ i ].releasedSfx     = LED_EI;
    // Create access mutex.
    Buttons[ i ].accessMutex = CreateMutex( NULL, FALSE, NULL );
    if ( Buttons[ i ].accessMutex == NULL )
      return( FALSE );
  }
  return( TRUE );
}


/*****************************************************************************
 *
 * BOOL LI_BUTTON_RemoveSystem( void )
 *
 *  Description:
 *    Shuts down the button system. Frees any objects that were created for
 *    display purposes and frees the mutex. Frees all memory allocated for
 *    the buttons in the list and turns them all invisible. This routine does
 *    NOT remove objects from the screen or destroy objects for text buttons.
 *    This is because by the time this routine is called, all datafiles have
 *    been closed.
 *
 *  Parameters:
 *    None.
 *
 *  Returns:
 *    TRUE if the button system was successfully closed.
 *
 *****************************************************************************/

BOOL LI_BUTTON_RemoveSystem( void )
{
  int i;

  // Clear all buttons in any of the lists.
  for( i=0; i< CE_ARTLIB_NumberOfButtonLists; i++ )
  {
    WaitForSingleObject( Buttons[ i ].accessMutex, INFINITE );
    if ( !( CloseHandle( Buttons[ i ].accessMutex ) ) )
      return( FALSE );
    Buttons[ i ].accessMutex = NULL;
    Buttons[ i ].numberOfButtons = 0;
    // Free memory allocated for buttons and sprites.
    if ( Buttons[ i ].buttons != NULL )
    {
      free( Buttons[ i ].buttons );
      Buttons[ i ].buttons = NULL;
    }
    if ( Buttons[ i ].sprites != NULL )
    {
      free( Buttons[ i ].sprites );
      Buttons[ i ].sprites = NULL;
    }
  }
  return( TRUE );
}


/*****************************************************************************
 *
 * void LE_BUTTON_SetSFX( int buttonList, LE_DATA_DataId pressedSFX, LE_DATA_DataId releasedSFX )
 *
 *  Description:
 *    Sets the sound effects for all buttons that are noisy. The sound effects
 *    take effect immediately.
 *
 *  Parameters:
 *    buttonList  - Button list to set sound effects for.
 *    pressedSFX  - Sound to play when a noisy button is pressed.
 *    releasedSFX - Sound to play when a noisy button is released.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

void LE_BUTTON_SetSFX( int buttonList, LE_DATA_DataId pressedSFX, LE_DATA_DataId releasedSFX )
{
  // Wait for access to the button list.
  WaitForSingleObject( Buttons[ buttonList ].accessMutex, INFINITE );
  // Set the sound effects, overwriting the previous values.
  Buttons[ buttonList ].pressedSfx  = pressedSFX;
  Buttons[ buttonList ].releasedSfx = releasedSFX;
  // Release mutex.
  ReleaseMutex( Buttons[ buttonList ].accessMutex );
}


/*****************************************************************************
 *
 * void LE_BUTTON_Activate( int buttonList, BOOL active )
 *
 *  Description:
 *    Activates or deactivates an entire button list. The effects take
 *    place immediately.
 *
 *  Parameters:
 *    buttonList  - Button list to set sound effects for.
 *    active      - Determines the active state for the button list.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

void LE_BUTTON_Activate( int buttonList, BOOL active )
{
  // Wait for access to the button list.
  WaitForSingleObject( Buttons[ buttonList ].accessMutex, INFINITE );
  // Set the sound effects, overwriting the previous values.
  Buttons[ buttonList ].active  = active;
  // Release mutex.
  ReleaseMutex( Buttons[ buttonList ].accessMutex );
}


/*****************************************************************************
 *
 * void LE_BUTTON_SetTextInfo( int buttonList, LE_BUTTON_TextInfoPointer textInfo )
 *
 *  Description:
 *    Sets the text info record for all text buttons drawn for the specified
 *    button list.
 *
 *  Parameters:
 *    buttonList  - Button list to set text info record.
 *    textInfo    - Pointer to text info record filled in by user.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

void LE_BUTTON_SetTextInfo( int buttonList, LE_BUTTON_TextInfoPointer textInfo )
{
  // Wait for access to the button list.
  WaitForSingleObject( Buttons[ buttonList ].accessMutex, INFINITE );
  // Set the text info structure.
  Buttons[ buttonList ].textInfo = *textInfo;
  // Release mutex.
  ReleaseMutex( Buttons[ buttonList ].accessMutex );
}


/*****************************************************************************
 *
 * void LE_BUTTON_SetRenderSlot( int buttonList, LE_REND_RenderSlot renderSlot )
 *
 *  Description:
 *    Sets the render slot for a button list.
 *
 *  Parameters:
 *    buttonList  - Button list to set text info record.
 *    renderSlot  - Render slot number.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/
#if CE_ARTLIB_EnableSystemSequencer
void LE_BUTTON_SetRenderSlot( int buttonList, LE_REND_RenderSlot renderSlot )
{
  // Wait for access to the button list.
  WaitForSingleObject( Buttons[ buttonList ].accessMutex, INFINITE );
  // Set the text info structure.
  Buttons[ buttonList ].renderSlot = renderSlot;
  // Release mutex.
  ReleaseMutex( Buttons[ buttonList ].accessMutex );
}
#endif


/*****************************************************************************
 *
 * void LE_BUTTON_GetState( int                         buttonList,
 *                          int                         button,
 *                          LE_BUTTON_DefinitionPointer butPtr )
 *
 *  Description:
 *    Return the current state of the button identified by the parameters
 *    buttonList and button and place the result in the passed pointer
 *    to a LE_BUTTON_DefintionRecord. The entire state of the button
 *    can be expressed through that record.
 *
 *  Parameters:
 *    buttonList, button  - Identifies the button.
 *    butPtr              - Pointer to buffer to store record.
 *
 *  Returns:
 *    None.
 *
 *****************************************************************************/

void LE_BUTTON_GetState( int buttonList, int button, LE_BUTTON_DefinitionPointer butPtr )
{
  LI_BUTTON_InternalButtonPointer but;

  // Wait for access to the button.
  WaitForSingleObject( Buttons[ buttonList ].accessMutex, INFINITE );
  // Make sure the button specified is a legal button.
  if ( LI_BUTTON_IsLegalButton( buttonList, button ) == TRUE )
  {
    // Find a pointer to the button in question.
    but = BUTTON_INTPTR( buttonList, button );
    // Copy information directly to buffer.
    *butPtr = but->record;
    // Release mutex.
    ReleaseMutex( Buttons[ buttonList ].accessMutex );
  }
}


/*****************************************************************************
 *
 * BOOL LE_BUTTON_UpdateButtonList( ... )
 *
 *  Description:
 *    Routine to define and modify entire button lists. The user supplies
 *    an array of LE_BUTTON_DefintionRecords and buttons are created based
 *    on the information given. Entire button lists can be created, destroyed
 *    and redefined. When buttons are destroyed or redefined, the existing
 *    buttons become invisible.
 *
 *  Parameters:
 *    buttonList    - identifies the button list to modify.
 *    numButtons    - the number of buttons defined in the argument buttonArray.
 *    buttonArray   - Pointer to the array of defintion records.
 *
 *  Returns:
 *    TRUE if the buttons were successfully created.
 *
 *****************************************************************************/

BOOL LE_BUTTON_UpdateButtonList( int buttonList, int numButtons, LE_BUTTON_DefinitionPointer buttonArray )
{
  LI_BUTTON_InternalButtonPointer intBut;
  LE_BUTTON_DefinitionPointer     oldBut, newBut;
  LE_DATA_DataId                  *deletedObjects;
  BOOL                            isFirst, isOn;
  short                           newFlags;
  int                             numDeletedObjects;
  int                             i, oldButtons;

  // If an illegal button list number is given, return immediately.
  if ( buttonList < 0 || buttonList >= CE_ARTLIB_NumberOfButtonLists )
    return( FALSE );

  // Obtain mutual access to the button list.
  WaitForSingleObject( Buttons[ buttonList ].accessMutex, INFINITE );

  // Save the current number of buttons in this list.
  oldButtons = Buttons[ buttonList ].numberOfButtons;

  // Allocate a space for all old objects.
  deletedObjects = (LE_DATA_DataId *)malloc( oldButtons * sizeof(LE_DATA_DataId) * 4 );
  numDeletedObjects = 0;

  // These values keep track of groups.
  isFirst = FALSE;
  isOn    = FALSE;

  // If the number of buttons in the new list is 0, this means the user wants
  // to deallocate all buttons in that list.
  if ( numButtons == 0 )
  {
    // First, hide all the buttons.
    for( i=0; i<oldButtons; i++ )
      LE_SPRITE_SetVisible( BUTTON_SPRPTR( buttonList, i ), FALSE );
    // Update sprites so the buttons disappear.
    LE_SPRITE_UpdateSprites( BUTTON_SPRPTR( buttonList, 0 ), oldButtons );
    // Now, free any text objects. Text objects can be defined only for ON, OFF
    // PRESSED and DISABLED states.
    for( i=0; i<oldButtons; i++ )
    {
      intBut = BUTTON_INTPTR( buttonList, i );
      if (intBut->record.offImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.offImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.offImage );
      if (intBut->record.onImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.onImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.onImage );
      if (intBut->record.pressedImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.pressedImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.pressedImage );
      if (intBut->record.disabledImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.disabledImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.disabledImage );
    }
    // Free memory allocated for buttons and sprites.
    if ( Buttons[ buttonList ].buttons != NULL )
    {
      free( Buttons[ buttonList ].buttons );
      Buttons[ buttonList ].buttons = NULL;
    }
    if ( Buttons[ buttonList ].sprites != NULL )
    {
      free( Buttons[ buttonList ].sprites );
      Buttons[ buttonList ].sprites = NULL;
    }
    // All done.
    Buttons[ buttonList ].numberOfButtons = 0;
    Buttons[ buttonList ].active = FALSE;
    ReleaseMutex( Buttons[ buttonList ].accessMutex );
    return( TRUE );
  }
  // If there are currently no buttons in the button list, it means memory
  // has not yet been allocated.
  else if ( oldButtons == 0 )
  {
    int blockSize;

    // Prepare the new list.
    Buttons[ buttonList ].numberOfButtons = numButtons;
    // Allocate memory for the button lists. We use malloc() for now.
    blockSize = numButtons * sizeof( LI_BUTTON_InternalButtonRecord );
    Buttons[ buttonList ].buttons  = (BUTTON_InternalButtonStruct *)malloc( blockSize );
    memset( Buttons[ buttonList ].buttons, 0, blockSize );
    // Allocate memory for the sprites for each button.
    blockSize = numButtons * sizeof( LE_SPRITE_Record );
    Buttons[ buttonList ].sprites  = (tagSprite *)malloc( blockSize );
    memset( Buttons[ buttonList ].sprites, 0, blockSize );
    // Extra check. Make sure all buttons in the given array have the
    // isNewState flag set. Also, initialize all the sprites.
    for( i=0; i< numButtons; i++ )
    {
      buttonArray[i].isNewState = TRUE;
      LE_SPRITE_Initialize( BUTTON_SPRPTR( buttonList, i, ), buttonArray[ i ].imagePriority );
      LE_SPRITE_SetRenderSlot( BUTTON_SPRPTR( buttonList, i ), Buttons[ buttonList ].renderSlot );
    }
  }
  // If the new list does not have the same number of buttons as the current list.
  else if ( numButtons != oldButtons )
  {
    int blockSize;

    // First, hide and remove any buttons that are no longer part of the list.
    for( i=numButtons; i<oldButtons; i++ )
      LE_SPRITE_SetVisible( BUTTON_SPRPTR( buttonList, i ), FALSE );
    // Update sprites so the buttons disappear.
    if ( oldButtons > numButtons )
      LE_SPRITE_UpdateSprites( BUTTON_SPRPTR( buttonList, numButtons ), oldButtons - numButtons );
    // Now, free any text objects.
    for( i=numButtons; i<oldButtons; i++ )
    {
      intBut = BUTTON_INTPTR( buttonList, i );
      if (intBut->record.offImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.offImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.offImage );
      if (intBut->record.onImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.onImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.onImage );
      if (intBut->record.pressedImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.pressedImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.pressedImage );
      if (intBut->record.disabledImage != LED_EI && LE_DATA_GetLoadedDataType( intBut->record.disabledImage ) == LE_DATA_DataNative )
        LE_DATA_FreeRuntimeDataID( intBut->record.disabledImage );
    }
    // Reallocate the memory for the new button list.
    Buttons[ buttonList ].numberOfButtons = numButtons;
    blockSize = numButtons * sizeof( LI_BUTTON_InternalButtonRecord );
    Buttons[ buttonList ].buttons = (BUTTON_InternalButtonStruct *)realloc( Buttons[ buttonList ].buttons, blockSize );
    // Reallocate memory for the sprites.
    blockSize = numButtons * sizeof( LE_SPRITE_Record );
    Buttons[ buttonList ].sprites = (tagSprite *)realloc( Buttons[ buttonList ].sprites, blockSize );
    // Extra check. Make sure all extra buttons have isNewState field set so
    // they will be changed. Also, initialize all the sprites.
    for( i=oldButtons; i<numButtons; i++ )
    {
      buttonArray[ i ].isNewState = TRUE;
      LE_SPRITE_Initialize( BUTTON_SPRPTR( buttonList, i, ), buttonArray[ i ].imagePriority );
      LE_SPRITE_SetRenderSlot( BUTTON_SPRPTR( buttonList, i ), Buttons[ buttonList ].renderSlot );
    }
  }

  // Assign button record.
  Buttons[ buttonList ].userRecords = buttonArray;

  // Go through the passed array button by button.
  for( i=0; i<numButtons; i++ )
  {
    // Create the button. First, get the internal button structure pointer.
    intBut = BUTTON_INTPTR( buttonList, i );
    newBut = &( buttonArray[ i ] );
    oldBut = ( i < oldButtons ) ? &( intBut->record ) : NULL;
    newFlags = BUTTON_FLAG_REDRAW_BUTTON;
    // If this is not a new button, save the previous control flags.
    if ( oldBut != NULL && newBut->buttonType == oldBut->buttonType )
      newFlags |= intBut->activationFlags & BUTTON_FLAG_CONTROLSTATES;

    // Correct any inconsistencies with the new record.
    switch( newBut->buttonType )
    {
      case BUTTON_TYPE_HOTSPOT:
        // Hotspot buttons can never be ON and must always be visible.
        // Also, they cannot ever have any images defined for them.
        newBut->isOn              = FALSE;
        newBut->isVisible         = TRUE;
        newBut->offImage          = LED_EI;
        newBut->pressedImage      = LED_EI;
        newBut->onImage           = LED_EI;
        newBut->disabledImage     = LED_EI;
        newBut->imagePriority     = 0;
        break;

      case BUTTON_TYPE_MOMENTARY:
        // Momentary buttons are never ON and therefore, never have
        // an ON image.
        newBut->isOn = FALSE;
        newBut->onImage = LED_EI;
        break;

      case BUTTON_TYPE_TOGGLE:
        // No restrictions on toggle buttons.
        break;

      case BUTTON_TYPE_RADIO:
        // Turn off any radio buttons in a group where there was already
        // one set to ON.
        newFlags |= ( isFirst ) ? 0 : BUTTON_FLAG_FIRSTINSET;
        isFirst = TRUE;
        newBut->isOn  = ( newBut->isOn & !( isOn ) );
        isOn |= newBut->isOn;
        break;

      case BUTTON_TYPE_LAST_RADIO:
        // If there hasn't been a radio button set to ON in this group,
        // force the last one ON and reset the alreadyOn flag.
        newFlags |= BUTTON_FLAG_LASTINSET;
        newBut->isOn = !( isOn );
        isOn = FALSE;
        isFirst = FALSE;
        break;

      case BUTTON_TYPE_CYCLE:
        // Cycle buttons must have a NULL off image. Also, if they are
        // not ON, they are not visible.
        newBut->offImage = LED_EI;
        newFlags |= ( isFirst ) ? 0 : BUTTON_FLAG_FIRSTINSET;
        isFirst = TRUE;
        newBut->isOn = ( newBut->isOn & !( isOn ) );
        isOn |= newBut->isOn;
        if ( newBut->isOn == FALSE )
          newBut->isVisible = FALSE;
        break;

      case BUTTON_TYPE_LAST_CYCLE:
        // Make sure at least one cycle button is ON.
        newBut->offImage = LED_EI;
        newFlags |= BUTTON_FLAG_LASTINSET;
        newBut->isOn = !( isOn );
        isOn = FALSE;
        isFirst = FALSE;
        if ( newBut->isOn == FALSE )
          newBut->isVisible = FALSE;
        break;
    }

    // Go through all the new images and convert any text strings to objects.
    if (newBut->onImage != LE_DATA_EmptyItem &&
    LE_DATA_GetLoadedDataType( newBut->onImage  ) == LE_DATA_DataString )
      newBut->onImage = LI_BUTTON_MakeTextButton( &( Buttons[ buttonList ].textInfo ), newBut->onImage, 1 );

    if (newBut->offImage != LE_DATA_EmptyItem &&
    LE_DATA_GetLoadedDataType( newBut->offImage ) == LE_DATA_DataString )
      newBut->offImage = LI_BUTTON_MakeTextButton( &( Buttons[ buttonList ].textInfo ), newBut->offImage, 0 );

    if (newBut->pressedImage != LE_DATA_EmptyItem &&
    LE_DATA_GetLoadedDataType( newBut->pressedImage ) == LE_DATA_DataString )
      newBut->pressedImage = LI_BUTTON_MakeTextButton( &( Buttons[ buttonList ].textInfo ), newBut->pressedImage, 0 );

    if (newBut->disabledImage != LE_DATA_EmptyItem &&
    LE_DATA_GetLoadedDataType( newBut->disabledImage ) == LE_DATA_DataString )
      newBut->disabledImage = LI_BUTTON_MakeTextButton( &( Buttons[ buttonList ].textInfo ), newBut->disabledImage, 2 );

    // Go through all the old images and determine if we should free their
    // objects. Do this only if the images are changing.
    // ON image.
    if ( oldBut && oldBut->onImage != newBut->onImage )
    {
      if (oldBut->onImage !=  LED_EI && LE_DATA_GetLoadedDataType( oldBut->onImage ) == LE_DATA_DataNative )
        deletedObjects[ numDeletedObjects++ ] = oldBut->onImage;
    }
    // OFF image.
    if ( oldBut && oldBut->offImage != newBut->offImage )
    {
      if (oldBut->offImage != LED_EI && LE_DATA_GetLoadedDataType( oldBut->offImage ) == LE_DATA_DataNative )
        deletedObjects[ numDeletedObjects++ ] = oldBut->offImage;
    }
    // PRESSED image
    if ( oldBut && oldBut->pressedImage != newBut->pressedImage )
    {
      if (oldBut->pressedImage !=  LED_EI && LE_DATA_GetLoadedDataType( oldBut->pressedImage ) == LE_DATA_DataNative )
        deletedObjects[ numDeletedObjects++ ] = oldBut->pressedImage;
    }
    // DISABLED image
    if ( oldBut && oldBut->disabledImage != newBut->disabledImage )
    {
      if (oldBut->disabledImage !=  LED_EI && LE_DATA_GetLoadedDataType( oldBut->disabledImage ) == LE_DATA_DataNative )
        deletedObjects[ numDeletedObjects++ ] = oldBut->disabledImage;
    }

    // If there is an existing button, copy over the old definition record with
    // the new record. If the new record is not setting a new state, save previous
    if ( oldBut != NULL )
    {
      LE_BUTTON_DefinitionRecord backupRecord;

      // Copy the new definition record to the old record.
      backupRecord = *oldBut;
      *oldBut = *newBut;
      // If the new button does not represent a new state, restore the
      // previous state from the backed up record.
      if ( newBut->isNewState == FALSE )
      {
        oldBut->isOn       = backupRecord.isOn;
        oldBut->isPressed  = backupRecord.isPressed;
        oldBut->isVisible  = backupRecord.isVisible;
        oldBut->isDisabled = backupRecord.isDisabled;
      }
    }
    else
      intBut->record = *newBut;

    // Make sure the isNewState flag gets reset to FALSE.
    newBut->isNewState = FALSE;

    // Collect the flags for activation. Duplicating them under one variable
    // name simplifies the checking when the buttons are processed for a message.
    intBut->activationFlags = newFlags;
    if ( newBut->activateLMB == TRUE )
      intBut->activationFlags |= BUTTON_FLAG_LMB;
    if ( newBut->activateMMB == TRUE )
      intBut->activationFlags |= BUTTON_FLAG_RMB;
    if ( newBut->activateRMB == TRUE )
      intBut->activationFlags |= BUTTON_FLAG_RMB;
    if ( newBut->activateRollOver == TRUE )
      intBut->activationFlags |= BUTTON_FLAG_MMOVE;
    if ( newBut->activateTrack == TRUE )
      intBut->activationFlags |= BUTTON_FLAG_MMOVE;

    // Assign the appropriate state handling procedure to the button.
    switch( newBut->buttonType )
    {
    case BUTTON_TYPE_HOTSPOT:
      intBut->setState = (PFUNC_BUTTONSETSTATE)LI_BUTTON_InternalSetStateForHotspot;
      break;
    case BUTTON_TYPE_TOGGLE:
      intBut->setState = (PFUNC_BUTTONSETSTATE)LI_BUTTON_InternalSetStateForToggle;
      break;
    case BUTTON_TYPE_RADIO:
    case BUTTON_TYPE_LAST_RADIO:
      intBut->setState = (PFUNC_BUTTONSETSTATE)LI_BUTTON_InternalSetStateForRadio;
      break;
    case BUTTON_TYPE_CYCLE:
    case BUTTON_TYPE_LAST_CYCLE:
      intBut->setState = (PFUNC_BUTTONSETSTATE)LI_BUTTON_InternalSetStateForCycle;
      break;
    default:
      intBut->setState = (PFUNC_BUTTONSETSTATE)LI_BUTTON_InternalSetStateForMomentary;
    } // ENDSWITCH
  } // End of FOR loop.

  // Play all transitions defined for buttons.
  LI_BUTTON_DoTransitions( buttonList );
  // Redraw all the buttons.
  LI_BUTTON_RedrawButtons( buttonList );

  // Activate entire list
  Buttons[ buttonList ].active = TRUE;

  // Free all objects marked for removal
  for( i=0; i<numDeletedObjects; i++ )
    LE_DATA_FreeRuntimeDataID( deletedObjects[ i ] );
  free( deletedObjects );

  // Release the access mutex.
  ReleaseMutex( Buttons[ buttonList ].accessMutex );
  return( TRUE );
}


/*****************************************************************************
 *
 *    Routine to process input messages and determine if they affect the
 *    buttons in all lists. Processing is done starting at the first list
 *    with the first button and proceeds through each button in that list.
 *    Then it processes buttons in the next list and so on. Processing stops
 *    when a button is activated that does not have transparent clicks
 *    enabled.
 *      Buttons that are pressed have a flag set. If the mouse cursor moves
 *    outside the hot area of the button and the mouse button has not been
 *    released, a BUTTON_TRANS_UNPRESS transition occurs and the button
 *    returns to its last unpressed state generating no events. When the button
 *    then gets released, if it is over a button that button will not generate
 *    an event or change state. If the mouse button is released over the hot area
 *    of the button, a BUTTON_TRANS_RELEASE transition occurs and the button will
 *    change state as necessary.
 *
 *****************************************************************************/

void LI_BUTTON_ProcessInputMessage (LE_UIMSG_MessageType MessageCode,
  int MouseX, int MouseY, UNS16 KeyCode)
{
  LI_BUTTON_InternalButtonPointer  but;
  LE_BUTTON_ActivationType         active;
  LE_UIMSG_MessageType             event;
  short                            flags;
  int                              i, j, processed;
  TYPE_Point2D                     screenPoint, worldPoint;
  BOOL                             bTrans, bRedraw;

  switch( MessageCode )
  {
    // Depending on the mouse message, set the event and jump to the
    // processing routine. Use a goto, really ugly but fast.
    case UIMSG_MOUSE_LEFT_DOWN:
      event  = UIMSG_BUTTON_PRESSED;
      active = BUTTON_ACTIVATE_LMB;
      flags  = BUTTON_FLAG_LMB;
      goto BUTTONTAG_PROCESSMOUSEEVENT;

    case UIMSG_MOUSE_LEFT_UP:
      event  = UIMSG_BUTTON_RELEASED;
      active = BUTTON_ACTIVATE_LMB;
      flags  = BUTTON_FLAG_LMB;
      goto BUTTONTAG_PROCESSMOUSEEVENT;

    case UIMSG_MOUSE_RIGHT_DOWN:
      event  = UIMSG_BUTTON_PRESSED;
      active = BUTTON_ACTIVATE_RMB;
      flags  = BUTTON_FLAG_RMB;
      goto BUTTONTAG_PROCESSMOUSEEVENT;

    case UIMSG_MOUSE_RIGHT_UP:
      event  = UIMSG_BUTTON_RELEASED;
      active = BUTTON_ACTIVATE_RMB;
      flags  = BUTTON_FLAG_RMB;
      goto BUTTONTAG_PROCESSMOUSEEVENT;

    case UIMSG_MOUSE_MOVED:
      event  = UIMSG_BUTTON_ROLL_ENTER;
      flags  = BUTTON_FLAG_MMOVE;

BUTTONTAG_PROCESSMOUSEEVENT:
      /*
      ** The location of the mouse when the event occured is stored
      ** in the lParam of the message.
      ** We also need to convert the coordinates to world coordinates
      ** using the render slot specified for each button list.
      ** We process each button list one at a time. Processing stops as
      ** soon as a button is activated that is not transparent.
      */
      screenPoint.x = MouseX;
      screenPoint.y = MouseY;
      processed = 0;
      for( i=0; i<CE_ARTLIB_NumberOfButtonLists && processed == 0; i++ )
      {
        // If the button list is not active, skip the whole thing.
        if ( Buttons[ i ].active == FALSE )
          continue;

        WaitForSingleObject( Buttons[ i ].accessMutex, INFINITE );
        bRedraw = bTrans = FALSE;

        #if CE_ARTLIB_EnableSystemSequencer
          LE_REND2D_ScreenToWorldCoordinates( Buttons[ i ].renderSlot,
                                              &screenPoint,
                                              &worldPoint );
        #else
          worldPoint.x = screenPoint.x;
          worldPoint.y = screenPoint.y;
        #endif

        /*
        ** First step. Process all buttons that are not activated
        ** ( which in this case means the mouse is not in their hot area )
        ** and send any UIMSG_BUTTON_RELEASED or UIMSG_BUTTON_ROLL_EXIT
        ** messages that have not yet been sent.
        ** This will eliminate the problem where a roll enter message is
        ** received before a roll exit message.
        */
        for( j=0; j<Buttons[ i ].numberOfButtons; j++ )
        {
          but = BUTTON_INTPTR( i, j );
          if ( !( PtInRect( &( but->record.rectangle ), worldPoint ) ) )
          {
            if ( but->activationFlags & BUTTON_FLAG_ROLLOVERSENT )
            {
              but->activationFlags &= ~BUTTON_FLAG_ROLLOVERSENT;
              /* Only proces the button if it is not disabled and visible */
              if ( but->record.isDisabled == FALSE && but->record.isVisible == TRUE )
              {
                if ( but->record.callbackFunction != NULL )
                  bTrans = but->record.callbackFunction( i, j, UIMSG_BUTTON_ROLL_EXIT, BUTTON_ACTIVATE_LMB );
                bRedraw = bTrans;
                LE_UIMSG_SendEvent( UIMSG_BUTTON_ROLL_EXIT, i, j, 0, worldPoint.x, worldPoint.y, NULL, 0 );
              }
            }
          }
        }

        /*
        ** Go through the list of buttons a second time.
        ** Check to see if any of the buttons are activated.
        ** A button is considered activated if the mouse is inside its
        ** hot region and it responds to the event that occured.
        */
        for( j=0; j<Buttons[ i ].numberOfButtons; j++ )
        {
          but = BUTTON_INTPTR( i, j );
          if ( PtInRect( &( but->record.rectangle ), worldPoint ) )
          {
            /*
            ** Skip all buttons that do not qualify for activation.
            ** To be activated, a button must :
            ** 1> NOT have already been processed.
            ** 2> NOT be disabled.
            ** 3> visible
            ** 4> Respond to the event occuring.
            */
            if ( processed                        ||
                 but->record.isDisabled == TRUE   ||
                 but->record.isVisible  == FALSE  ||
                !( but->activationFlags & flags ) )
              continue;
            /*
            ** If this button is not transparent, processing will stop
            ** after this button is processed.
            */
            if ( but->record.transparentClicks == FALSE )
              processed++;

            /*
            ** Process all individual events.
            ** When a button is processed for an event, the callback
            ** function is called if one is defined, the button state
            ** is changed and if applicable, a message is generated. For
            ** some events like button presses, messages are sent during
            ** calls to change the button state.
            */
            switch( event )
            {
            case UIMSG_BUTTON_ROLL_ENTER:
              /*
              ** Process ROLL_ENTER messages.
              */
              if ( but->record.activateRollOver )
              {
                /* Only send a rollover message if one hasn't been sent. */
                if ( !( but->activationFlags & BUTTON_FLAG_ROLLOVERSENT ) )
                {
                  if ( but->record.callbackFunction != NULL )
                    bTrans = but->record.callbackFunction( i, j, event, BUTTON_ACTIVATE_LMB );
                  bRedraw = bTrans;
                  but->activationFlags |= BUTTON_FLAG_ROLLOVERSENT;
                  LE_UIMSG_SendEvent( event, i, j, 0, worldPoint.x, worldPoint.y, NULL, 0 );
                }
              }
              /* If tracking is enabled, send a tracking message. */
              if ( but->record.activateTrack )
                LE_UIMSG_SendEvent( UIMSG_BUTTON_TRACK, i, j, 0, worldPoint.x, worldPoint.y, NULL, 0 );
              break;

            case UIMSG_BUTTON_PRESSED:
              /*
              ** Process BUTTON_PRESSED messages.
              */
              if ( but->record.callbackFunction != NULL )
                bTrans = but->record.callbackFunction( i, j, event, active );
              bRedraw = TRUE;
              but->setState( i, j, BUTTON_TRANS_PRESS, event, active, worldPoint );
              but->activationFlags |= BUTTON_FLAG_BUTTONDOWN;
              if ( but->record.isNoisy && Buttons[ i ].pressedSfx != LED_EI )
                LE_SEQNCR_Start( Buttons[ i ].pressedSfx, FALSE );
              break;

            case UIMSG_BUTTON_RELEASED:
              /*
              ** Process BUTTON_RELEASED messages.
              */
              if ( but->record.callbackFunction != NULL )
                bTrans = but->record.callbackFunction( i, j, event, active );
              bRedraw = TRUE;
              but->setState( i, j, BUTTON_TRANS_RELEASE, event, active, worldPoint );
              but->activationFlags &= ~BUTTON_FLAG_BUTTONDOWN;
              if ( but->record.isNoisy && Buttons[ i ].releasedSfx != LED_EI )
                LE_SEQNCR_Start( Buttons[ i ].releasedSfx, FALSE );
              break;
            }
          }

          /*
          ** If we reach this point, this means the button is not being
          ** activated. Make sure any pending messages have been sent.
          */
          else
          {
            /*
            ** Force the button to a released state if the button was
            ** released and the button processed a BUTTON_PRESSED message.
            ** Because we are processing this event here, it means that
            ** the button was released while the mouse was not over the
            ** button. We need to change the state of the button but not
            ** generate any messages. This is acheived using a
            ** BUTTON_TRANS_UNPRESS event.
            */
            if ( but->activationFlags & BUTTON_FLAG_BUTTONDOWN )
            {
              but->activationFlags &= ~BUTTON_FLAG_BUTTONDOWN;
              if ( but->record.isDisabled == FALSE && but->record.isVisible == TRUE )
              {
                but->setState( i, j, BUTTON_TRANS_UNPRESS, event, active, worldPoint );
                bRedraw = TRUE;
              }
            }
          }
        }

        /* Play any transitions if any started and redraw if necessary. */
        if ( bTrans )
          LI_BUTTON_DoTransitions( i );
        if ( bRedraw )
          LI_BUTTON_RedrawButtons( i );

        ReleaseMutex( Buttons[ i ].accessMutex );
      }
      break;

    // Process for keyboard messages.
    case UIMSG_KEYBOARD_PRESSED:
      event  = UIMSG_BUTTON_PRESSED;
      active = BUTTON_ACTIVATE_KEY;
      goto BUTTONTAG_PROCESSKEYEVENT;

    case UIMSG_KEYBOARD_RELEASED:
      event = UIMSG_BUTTON_RELEASED;
      active = BUTTON_ACTIVATE_KEY;

BUTTONTAG_PROCESSKEYEVENT:
      // Process for a key press.
      processed = 0;
      worldPoint.x = 0;
      worldPoint.y = 0;
      for( i=0; i<CE_ARTLIB_NumberOfButtonLists; i++ )
      {
        // If the button list is not active, skip the whole thing.
        if ( Buttons[ i ].active == FALSE )
          continue;
        // Obtain mutual access to the button list.
        WaitForSingleObject( Buttons[ i ].accessMutex, INFINITE );
        bRedraw = bTrans = FALSE;
        // Go through every button in the list.
        for( j=0; j<Buttons[ i ].numberOfButtons; j++ )
        {
          if ( processed )
            continue;
          // Get a pointer to the internal button record.
          but = BUTTON_INTPTR( i, j );
          // Skip buttons that are disabled or hidden.
          if ( but->record.isDisabled || ! but->record.isVisible )
            continue;
          // If the button responds to this keypress.
          if ( but->record.physicalButtons.PC.keyboardCharacter == KeyCode )
          {
            if ( event == UIMSG_BUTTON_PRESSED )
            {
              // Callback function.
              if ( but->record.callbackFunction != NULL )
                bTrans = but->record.callbackFunction( i, j, event, active );
              bRedraw = TRUE;
              but->setState( i, j, BUTTON_TRANS_PRESS, event, active, worldPoint );
              // Play sound effect if button is noisy and sound defined.
              if ( but->record.isNoisy && Buttons[ i ].pressedSfx != LED_EI )
                LE_SEQNCR_Start( Buttons[ i ].pressedSfx, FALSE );
            }
            else
            {
              // Callback function.
              if ( but->record.callbackFunction != NULL )
                bTrans = but->record.callbackFunction( i, j, event, active );
              bRedraw = TRUE;
              but->setState( i, j, BUTTON_TRANS_RELEASE, event, active, worldPoint );
              // Play sound effect if button is noisy and sound defined.
              if ( but->record.isNoisy && Buttons[ i ].releasedSfx != LED_EI )
                LE_SEQNCR_Start( Buttons[ i ].releasedSfx, FALSE );
            }
            // Stop processing if this button is not transparent.
            if ( but->record.transparentClicks == FALSE )
              processed++;
          }
        } // for ( ) ...

        // Play any transitions.
        if ( bTrans )
          LI_BUTTON_DoTransitions( i );
        if ( bRedraw )
          LI_BUTTON_RedrawButtons( i );

        // Release the access mutex.
        ReleaseMutex( Buttons[ i ].accessMutex );
      }
      break;
  }
}



/*****************************************************************************
 * Adapter to use Windows messages rather than UIMSG messages.
 */

void LI_BUTTON_ProcessWindowsMessage( UINT message, WPARAM wParam, LPARAM lParam )
{
  UNS16                 KeyCode;
  int                   MouseX;
  int                   MouseY;
  LE_UIMSG_MessageType  UIMessage;

  KeyCode = wParam;
  MouseX = LOWORD (lParam);
  MouseY = HIWORD (lParam);

  switch (message)
  {
    case WM_LBUTTONDOWN:
      UIMessage = UIMSG_MOUSE_LEFT_DOWN;
      break;

    case WM_LBUTTONUP:
      UIMessage = UIMSG_MOUSE_LEFT_UP;
      break;

    case WM_RBUTTONDOWN:
      UIMessage = UIMSG_MOUSE_RIGHT_DOWN;
      break;

    case WM_RBUTTONUP:
      UIMessage = UIMSG_MOUSE_RIGHT_UP;
      break;

    case WM_MOUSEMOVE:
      UIMessage = UIMSG_MOUSE_MOVED;
      break;

    case WM_KEYDOWN:
      UIMessage = UIMSG_KEYBOARD_PRESSED;
      break;

    case WM_KEYUP:
      UIMessage = UIMSG_KEYBOARD_RELEASED;
      break;

    default: // A Windows message we don't care about.
      return;
  }

  LI_BUTTON_ProcessInputMessage (UIMessage, MouseX, MouseY, KeyCode);
}

#endif // CE_ARTLIB_EnableSystemButton
